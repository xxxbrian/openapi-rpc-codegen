// Code generated by openapi-rpc-codegen (go-server). DO NOT EDIT.

package {{ .Package }}

import (
	"context"
	"net/http"

	"github.com/go-chi/chi/v5"
)

{{- /* Path structs + inline Body/Resp only when needed */}}

{{- range .Tags }}
{{- range .Routes }}

{{- if .HasPath }}
type {{ .PathType }} struct {
{{- range .PathFields }}
	{{ .Name }} {{ .Type }}
{{- end }}
}
{{- end }}

{{- if .HasBody }}
{{- if .BodyInline }}
type {{ .BodyType }} = any
{{- end }}
{{- end }}

{{- if .RespInline }}
type {{ .RespType }} = any
{{- end }}

{{- end }}
{{- end }}

{{- /* Service interfaces per Tag */}}

{{- range .Tags }}

type {{ .Name }}Service interface {
{{- range .Routes }}
	{{ goMethodName .Name }}(ctx context.Context{{ if .HasPath }}, path {{ .PathType }}{{ end }}{{ if .HasQuery }}, query *{{ .QueryType }}{{ end }}{{ if .HasBody }}, body {{ .BodyType }}{{ end }}) ({{ .RespType }}, error)
{{- end }}
}

{{- end }}

type Services struct {
{{- range .Tags }}
	{{ .Name }} {{ .Name }}Service
{{- end }}
}

func RegisterRoutes(r chi.Router, svc Services) {
{{- range .Tags }}
	if svc.{{ .Name }} == nil {
		panic("Services.{{ .Name }} is nil")
	}
{{- end }}

{{- range .Tags }}
{{- range .Routes }}
	r.{{ .Method }}({{ printf "%q" .Path }}, {{ .HandlerName }}(svc.{{ .TagName }}))
{{- end }}
{{- end }}
}

{{- /* Handlers */}}

{{- range .Tags }}
{{- range .Routes }}

func {{ .HandlerName }}(svc {{ .TagName }}Service) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		ctx := r.Context()

		{{- if .HasPath }}
		var path {{ .PathType }}
		{{- range .PathFields }}
		path.{{ .Name }} = chi.URLParam(r, {{ printf "%q" .JSONName }})
		{{- end }}
		{{- end }}

		{{- if .HasQuery }}
		// TODO: typed query parsing (future)
		var query {{ .QueryType }}
		_ = query
		{{- end }}

		{{- if .HasBody }}
		var body {{ .BodyType }}
		if err := ReadJSON(r, &body); err != nil {
			WriteError(w, &RPCError{Status: http.StatusBadRequest, Message: "invalid json", Data: err.Error()})
			return
		}
		{{- end }}

		resp, err := svc.{{ goMethodName .Name }}(ctx{{ if .HasPath }}, path{{ end }}{{ if .HasQuery }}, &query{{ end }}{{ if .HasBody }}, body{{ end }})
		if err != nil {
			WriteError(w, err)
			return
		}
		WriteJSON(w, http.StatusOK, resp)
	}
}

{{- end }}
{{- end }}
