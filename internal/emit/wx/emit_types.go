package wx

import (
	"bytes"
	"fmt"
	"path/filepath"
	"sort"
	"strings"

	"github.com/xxxbrian/openapi-rpc-codegen/internal/emit/common"
	"github.com/xxxbrian/openapi-rpc-codegen/internal/ir"
)

type EmitOptions struct {
	OutDir string
	Check  bool
}

func EmitTypes(spec *ir.Spec, opt EmitOptions) ([]string, error) {
	if spec == nil {
		return nil, fmt.Errorf("nil IR spec")
	}

	outPath := filepath.Join(opt.OutDir, "types.gen.ts")

	var b bytes.Buffer
	b.WriteString(header())

	// Deterministic order
	names := make([]string, 0, len(spec.Types))
	for name := range spec.Types {
		names = append(names, name)
	}
	sort.Strings(names)

	for _, name := range names {
		td := spec.Types[name]
		if td.Name == "" {
			td.Name = name
		}

		code, err := emitTypeDecl(td)
		if err != nil {
			return nil, fmt.Errorf("emit type %s: %w", name, err)
		}
		b.WriteString(code)
		b.WriteString("\n\n")
	}

	wrote, err := common.WriteFile(outPath, b.Bytes(), common.WriteOptions{Check: opt.Check})
	if err != nil {
		return nil, err
	}

	// Return list of files that were written/changed; in check mode we won't get here unless ok
	if wrote {
		return []string{outPath}, nil
	}
	return []string{}, nil
}

func header() string {
	return strings.Join([]string{
		"/*",
		" * AUTO-GENERATED FILE - DO NOT EDIT.",
		" * Generated by openapi-rpc-codegen (ts-wx).",
		" */",
		"",
	}, "\n")
}

func emitTypeDecl(td ir.TypeDecl) (string, error) {
	name := sanitizeTSIdent(td.Name)
	if name == "" {
		return "", fmt.Errorf("invalid type name %q", td.Name)
	}

	switch td.Type.Kind {
	case ir.KindObject:
		return emitInterface(name, td.Type), nil
	case ir.KindEnum:
		return fmt.Sprintf("export type %s = %s%s;",
			name,
			strings.Join(quoteUnion(td.Type.Enum), " | "),
			nullableSuffix(td.Type.Nullable),
		), nil
	case ir.KindArray, ir.KindScalar:
		return fmt.Sprintf("export type %s = %s%s;", name, renderType(td.Type, 0), nullableSuffix(td.Type.Nullable)), nil
	default:
		return "", fmt.Errorf("unsupported kind: %s", td.Type.Kind)
	}
}

func emitInterface(name string, t ir.Type) string {
	var b strings.Builder
	b.WriteString("export interface ")
	b.WriteString(name)
	b.WriteString(" {\n")

	for _, f := range t.Fields {
		fieldName := f.Name
		optional := !f.Required

		// Use quoted property if not a safe identifier
		prop := fieldName
		if !isSafeTSProp(fieldName) {
			prop = fmt.Sprintf("%q", fieldName)
		}

		b.WriteString("  ")
		b.WriteString(prop)
		if optional {
			b.WriteString("?")
		}
		b.WriteString(": ")
		b.WriteString(renderTypeRef(f.Type, 1))
		b.WriteString(";\n")
	}

	b.WriteString("}")
	// Nullable object: `interface X {}` can't be unioned inline nicely via suffix,
	// so we provide an alias if Nullable.
	if t.Nullable {
		// emit: interface X {...}\nexport type XNullable = X | null;
		b.WriteString("\nexport type ")
		b.WriteString(name)
		b.WriteString("Nullable = ")
		b.WriteString(name)
		b.WriteString(" | null;")
	}
	return b.String()
}

func renderType(t ir.Type, indent int) string {
	switch t.Kind {
	case ir.KindScalar:
		switch t.Scalar {
		case "string":
			return "string"
		case "number":
			return "number"
		case "integer":
			// TS has only number
			return "number"
		case "boolean":
			return "boolean"
		default:
			return "unknown"
		}
	case ir.KindEnum:
		return strings.Join(quoteUnion(t.Enum), " | ") + nullableSuffix(t.Nullable)
	case ir.KindArray:
		if t.Elem == nil {
			return "unknown[]"
		}
		return renderTypeRef(*t.Elem, indent) + "[]"
	case ir.KindObject:
		// inline object type literal
		var b strings.Builder
		b.WriteString("{\n")
		for _, f := range t.Fields {
			prop := f.Name
			if !isSafeTSProp(prop) {
				prop = fmt.Sprintf("%q", prop)
			}
			b.WriteString(strings.Repeat("  ", indent+1))
			b.WriteString(prop)
			if !f.Required {
				b.WriteString("?")
			}
			b.WriteString(": ")
			b.WriteString(renderTypeRef(f.Type, indent+1))
			b.WriteString(";\n")
		}
		b.WriteString(strings.Repeat("  ", indent))
		b.WriteString("}")
		if t.Nullable {
			b.WriteString(" | null")
		}
		return b.String()
	default:
		return "unknown"
	}
}

func renderTypeRef(tr ir.TypeRef, indent int) string {
	if tr.RefName != "" {
		return sanitizeTSIdent(tr.RefName)
	}
	if tr.Inline != nil {
		return renderType(*tr.Inline, indent)
	}
	return "unknown"
}

func quoteUnion(vals []string) []string {
	out := make([]string, 0, len(vals))
	for _, v := range vals {
		out = append(out, fmt.Sprintf("%q", v))
	}
	if len(out) == 0 {
		return []string{"never"}
	}
	return out
}

func nullableSuffix(nullable bool) string {
	if nullable {
		return " | null"
	}
	return ""
}

func sanitizeTSIdent(s string) string {
	s = strings.TrimSpace(s)
	if s == "" {
		return ""
	}
	// Keep it simple: assume schema names are already sane; replace invalid chars with _
	var b strings.Builder
	for i, r := range s {
		isLetter := (r >= 'A' && r <= 'Z') || (r >= 'a' && r <= 'z')
		isDigit := (r >= '0' && r <= '9')
		if isLetter || isDigit || r == '_' {
			b.WriteRune(r)
		} else {
			b.WriteByte('_')
		}
		if i == 0 && isDigit {
			// prefix underscore for leading digit
			// We'll just handle after build too.
		}
	}
	out := b.String()
	if out != "" && out[0] >= '0' && out[0] <= '9' {
		out = "_" + out
	}
	return out
}

func isSafeTSProp(s string) bool {
	if s == "" {
		return false
	}
	// Simple JS identifier check
	for i, r := range s {
		isLetter := (r >= 'A' && r <= 'Z') || (r >= 'a' && r <= 'z') || r == '_' || r == '$'
		isDigit := (r >= '0' && r <= '9')
		if i == 0 {
			if !isLetter {
				return false
			}
		} else {
			if !(isLetter || isDigit) {
				return false
			}
		}
	}
	return true
}
